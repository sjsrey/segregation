<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>segregation.spatial.spatial_indexes &#8212; segregation v1.5.0 Manual</title>
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/pysal-styles.css" />
    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../../_static/js/jquery-1.12.4.min.js "></script>
<script type="text/javascript" src="../../../_static/js/jquery-fix.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-3.4.1/js/bootstrap.min.js "></script>
<script type="text/javascript" src="../../../_static/bootstrap-sphinx.js "></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../../index.html">
          segregation</a>
        <span class="navbar-text navbar-version pull-left"><b>1.5.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../../installation.html">Installation</a></li>
                <li><a href="../../../api.html">API</a></li>
                <li><a href="../../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for segregation.spatial.spatial_indexes</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Spatial based Segregation Metrics</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Renan X. Cortes &lt;renanc@ucr.edu&gt;, Sergio J. Rey &lt;sergio.rey@ucr.edu&gt; and Elijah Knaap &lt;elijah.knaap@ucr.edu&gt;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">libpysal</span>

<span class="kn">from</span> <span class="nn">libpysal.weights</span> <span class="kn">import</span> <span class="n">Queen</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">,</span> <span class="n">lag_spatial</span>
<span class="kn">from</span> <span class="nn">libpysal.weights.util</span> <span class="kn">import</span> <span class="n">fill_diagonal</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">inf</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="kn">import</span> <span class="n">manhattan_distances</span><span class="p">,</span> <span class="n">euclidean_distances</span><span class="p">,</span> <span class="n">haversine_distances</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.interpolation</span> <span class="kn">import</span> <span class="n">shift</span>

<span class="kn">from</span> <span class="nn">scipy.sparse.csgraph</span> <span class="kn">import</span> <span class="n">floyd_warshall</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">csr_matrix</span>

<span class="kn">from</span> <span class="nn">segregation.aspatial.aspatial_indexes</span> <span class="kn">import</span> <span class="n">_dissim</span><span class="p">,</span> <span class="n">MinMax</span>
<span class="kn">from</span> <span class="nn">segregation.aspatial.multigroup_aspatial_indexes</span> <span class="kn">import</span> <span class="n">MultiInformationTheory</span><span class="p">,</span> <span class="n">MultiDivergence</span>
<span class="kn">from</span> <span class="nn">segregation.network</span> <span class="kn">import</span> <span class="n">calc_access</span>
<span class="kn">from</span> <span class="nn">libpysal.weights.util</span> <span class="kn">import</span> <span class="n">attach_islands</span>

<span class="kn">from</span> <span class="nn">segregation.util.util</span> <span class="kn">import</span> <span class="n">_dep_message</span><span class="p">,</span> <span class="n">DeprecationHelper</span><span class="p">,</span> <span class="n">_nan_handle</span>

<span class="c1"># Including old and new api in __all__ so users can use both</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>

    <span class="s1">&#39;Spatial_Prox_Prof&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;SpatialProxProf&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Spatial_Dissim&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;SpatialDissim&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Boundary_Spatial_Dissim&#39;</span><span class="p">,</span>
    <span class="s1">&#39;BoundarySpatialDissim&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Perimeter_Area_Ratio_Spatial_Dissim&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;PerimeterAreaRatioSpatialDissim&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;SpatialMinMax&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Distance_Decay_Isolation&#39;</span><span class="p">,</span>
    <span class="s1">&#39;DistanceDecayIsolation&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Distance_Decay_Exposure&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;DistanceDecayExposure&#39;</span><span class="p">,</span> 
    
    <span class="s1">&#39;Spatial_Proximity&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;SpatialProximity&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Absolute_Clustering&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AbsoluteClustering&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Relative_Clustering&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;RelativeClustering&#39;</span><span class="p">,</span> 
    
    <span class="s1">&#39;Delta&#39;</span><span class="p">,</span> 
    
    <span class="s1">&#39;Absolute_Concentration&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AbsoluteConcentration&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Relative_Concentration&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;RelativeConcentration&#39;</span><span class="p">,</span> 
    
    <span class="s1">&#39;Absolute_Centralization&#39;</span><span class="p">,</span>
    <span class="s1">&#39;AbsoluteCentralization&#39;</span><span class="p">,</span>
    
    <span class="s1">&#39;Relative_Centralization&#39;</span><span class="p">,</span> 
    <span class="s1">&#39;RelativeCentralization&#39;</span><span class="p">,</span> 
    
    <span class="s1">&#39;SpatialInformationTheory&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SpatialDivergence&#39;</span><span class="p">,</span>

    <span class="s1">&#39;compute_segregation_profile&#39;</span>
<span class="p">]</span>

<span class="c1"># The Deprecation calls of the classes are located in the end of this script #</span>

<span class="c1"># suppress numpy divide by zero warnings because it occurs a lot during the</span>
<span class="c1"># calculation of many indices</span>
<span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_build_local_environment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert observations into spatially-weighted sums.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : DataFrame</span>
<span class="sd">        dataframe with local observations</span>
<span class="sd">    w : libpysal.weights object</span>
<span class="sd">        weights matrix defining the local environment</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    DataFrame</span>
<span class="sd">        Spatialized data</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">fill_diagonal</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">groups</span><span class="p">]:</span>
        <span class="n">new_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lag_spatial</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
    <span class="n">new_data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">new_data</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">new_data</span>


<span class="k">def</span> <span class="nf">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a PySAL weights object that the weights represent the length of the common boundary of two areal units that share border.</span>
<span class="sd">    Author: Levi Wolf &lt;levi.john.wolf@gmail.com&gt;. </span>
<span class="sd">    Thank you, Levi!</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a &#39;geometry&#39; column.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Currently it&#39;s not making any projection.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">w</span> <span class="o">=</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">Rook</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">geom_col</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">islands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="p">(</span><span class="s1">&#39;There are some islands in the GeoDataFrame.&#39;</span><span class="p">)</span>
        <span class="n">w_aux</span> <span class="o">=</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">KNN</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">geom_col</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">attach_islands</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w_aux</span><span class="p">)</span>

    <span class="n">adjlist</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">to_adjlist</span><span class="p">()</span>
    <span class="n">islands</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_records</span><span class="p">([{</span>
        <span class="s1">&#39;focal&#39;</span><span class="p">:</span> <span class="n">island</span><span class="p">,</span>
        <span class="s1">&#39;neighbor&#39;</span><span class="p">:</span> <span class="n">island</span><span class="p">,</span>
        <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">0</span>
    <span class="p">}</span> <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">islands</span><span class="p">])</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">adjlist</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">),</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;focal&#39;</span><span class="p">,</span>
                           <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>\
                    <span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">),</span> <span class="n">left_on</span><span class="o">=</span><span class="s1">&#39;neighbor&#39;</span><span class="p">,</span>
                           <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;_focal&quot;</span><span class="p">,</span> <span class="s2">&quot;_neighbor&quot;</span><span class="p">))</span>\

    <span class="c1"># Transforming from pandas to geopandas</span>
    <span class="n">merged</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">merged</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="s1">&#39;geometry_focal&#39;</span><span class="p">)</span>
    <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;geometry_neighbor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">(</span><span class="n">merged</span><span class="o">.</span><span class="n">geometry_neighbor</span><span class="p">)</span>

    <span class="c1"># Getting the shared boundaries</span>
    <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;shared_boundary&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">geometry_focal</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
        <span class="n">merged</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry_neighbor&#39;</span><span class="p">))</span>

    <span class="c1"># Putting it back to a matrix</span>
    <span class="n">merged</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;shared_boundary&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">length</span>
    <span class="n">merged_with_islands</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">((</span><span class="n">merged</span><span class="p">,</span> <span class="n">islands</span><span class="p">))</span>
    <span class="n">length_weighted_w</span> <span class="o">=</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="o">.</span><span class="n">from_adjlist</span><span class="p">(</span>
        <span class="n">merged_with_islands</span><span class="p">[[</span><span class="s1">&#39;focal&#39;</span><span class="p">,</span> <span class="s1">&#39;neighbor&#39;</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">]])</span>
    <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="n">w</span><span class="o">.</span><span class="n">islands</span><span class="p">:</span>
        <span class="n">length_weighted_w</span><span class="o">.</span><span class="n">neighbors</span><span class="p">[</span><span class="n">island</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">del</span> <span class="n">length_weighted_w</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">island</span><span class="p">]</span>

    <span class="n">length_weighted_w</span><span class="o">.</span><span class="n">_reset</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">length_weighted_w</span>


<span class="k">def</span> <span class="nf">_spatial_prox_profile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity Profile</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    m             : int</span>
<span class="sd">                    a numeric value indicating the number of thresholds to be used. Default value is 1000. </span>
<span class="sd">                    A large value of m creates a smoother-looking graph and a more precise spatial proximity profile value but slows down the calculation speed.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Hong, Seong-Yun, and Yukio Sadahiro. &quot;Measuring geographic segregation: a graph-based approach.&quot; Journal of Geographical Systems 16.2 (2014): 211-231.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`hong2014measuring`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;m must be a string.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;m must be greater than 1.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="c1"># Create the shortest distance path between two pair of units using Shimbel matrix. This step was well discussed in https://github.com/pysal/segregation/issues/5.</span>
    <span class="n">w_libpysal</span> <span class="o">=</span> <span class="n">Queen</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span><span class="n">w_libpysal</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">floyd_warshall</span><span class="p">(</span><span class="n">csgraph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">directed</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">calculate_etat</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">g_t_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&gt;=</span> <span class="n">t</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
                         <span class="kc">False</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">g_t_i</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># i and j only varies in the units subset within the threshold in eta_t of Hong (2014).</span>
        <span class="n">sub_delta_ij</span> <span class="o">=</span> <span class="n">delta</span><span class="p">[</span><span class="n">g_t_i</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">g_t_i</span><span class="p">]</span>

        <span class="n">den</span> <span class="o">=</span> <span class="n">sub_delta_ij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">eta_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="n">den</span>
        <span class="k">return</span> <span class="n">eta_t</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="n">aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">calculate_etat</span><span class="p">,</span> <span class="n">grid</span><span class="p">)))</span>
    <span class="n">aux</span><span class="p">[</span><span class="n">aux</span> <span class="o">==</span> <span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">aux</span><span class="p">[</span><span class="n">aux</span> <span class="o">==</span> <span class="o">-</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">curve</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">aux</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">SPP</span> <span class="o">=</span> <span class="p">((</span><span class="n">threshold</span> <span class="o">-</span> <span class="p">((</span><span class="n">curve</span><span class="p">[</span><span class="n">grid</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">m</span> <span class="o">-</span>
                         <span class="p">(</span><span class="n">curve</span><span class="p">[</span><span class="n">grid</span> <span class="o">&gt;=</span> <span class="n">threshold</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">m</span><span class="p">))</span> <span class="o">/</span>
           <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">threshold</span><span class="p">))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SPP</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">curve</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="SpatialProxProf"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialProxProf.html#segregation.spatial.SpatialProxProf">[docs]</a><span class="k">class</span> <span class="nc">SpatialProxProf</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity Profile</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    m             : int</span>
<span class="sd">                    a numeric value indicating the number of thresholds to be used. Default value is 1000. </span>
<span class="sd">                    A large value of m creates a smoother-looking graph and a more precise spatial proximity profile value but slows down the calculation speed.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Profile Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the spatial proximity profile (SPP) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import SpatialProxProf</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spat_prox_index = SpatialProxProf(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spat_prox_index.statistic</span>
<span class="sd">    0.11217269612149207</span>
<span class="sd">    </span>
<span class="sd">    You can plot the profile curve with the plot method.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spat_prox_index.plot()</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Hong, Seong-Yun, and Yukio Sadahiro. &quot;Measuring geographic segregation: a graph-based approach.&quot; Journal of Geographical Systems 16.2 (2014): 211-231.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`hong2014measuring`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpatialProxProf.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialProxProf.html#segregation.spatial.SpatialProxProf.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_prox_profile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">curve</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_prox_profile</span></div>

<div class="viewcode-block" id="SpatialProxProf.plot"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialProxProf.html#segregation.spatial.SpatialProxProf.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the Spatial Proximity Profile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;This method relies on importing `matplotlib`&#39;</span><span class="p">)</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">curve</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span></div></div>


<span class="k">def</span> <span class="nf">_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                    <span class="n">group_pop_var</span><span class="p">,</span>
                    <span class="n">total_pop_var</span><span class="p">,</span>
                    <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    w             : W</span>
<span class="sd">                    A PySAL weights object. If not provided, Queen contiguity matrix is used.</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default with row standardization.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Morrill, R. L. (1991) &quot;On the Measure of Geographic Segregation&quot;. Geography Research Forum.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morrill1991measure`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;std is not a boolean object&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">w_object</span> <span class="o">=</span> <span class="n">Queen</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">w_object</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">w_object</span><span class="p">),</span> <span class="n">libpysal</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">W</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;w is not a PySAL weights object&#39;</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="c1"># If a unit has zero population, the group of interest frequency is zero</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span> <span class="o">/</span> <span class="n">t</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">w_object</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">w_object</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">cij</span> <span class="o">/</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">cij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Inspired in (second solution): https://stackoverflow.com/questions/22720864/efficiently-calculating-a-euclidean-distance-matrix-using-numpy</span>
    <span class="c1"># Distance Matrix</span>
    <span class="n">abs_dist</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">-</span> <span class="n">pi</span><span class="p">)</span>

    <span class="c1"># manhattan_distances used to compute absolute distances</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">abs_dist</span><span class="p">,</span> <span class="n">cij</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">SD</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
    <span class="n">SD</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SD</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="SpatialDissim"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialDissim.html#segregation.spatial.SpatialDissim">[docs]</a><span class="k">class</span> <span class="nc">SpatialDissim</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    w             : W</span>
<span class="sd">                    A PySAL weights object. If not provided, Queen contiguity matrix is used.</span>
<span class="sd">    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default with row standardization.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.   </span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of spatial dissimilarity (D) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset. The neighborhood contiguity matrix is used.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import SpatialDissim</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index = SpatialDissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index.statistic</span>
<span class="sd">    0.2864885055405311</span>
<span class="sd">        </span>
<span class="sd">    To use different neighborhood matrices:</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; from libpysal.weights import Rook, KNN</span>
<span class="sd">    </span>
<span class="sd">    Assuming K-nearest neighbors with k = 4</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; knn = KNN.from_dataframe(gdf, k=4)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index = Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;, w = knn)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index.statistic</span>
<span class="sd">    0.28544347200877285</span>
<span class="sd">    </span>
<span class="sd">    Assuming Rook contiguity neighborhood</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; roo = Rook.from_dataframe(gdf)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index = Spatial_Dissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;, w = roo)</span>
<span class="sd">    &gt;&gt;&gt; spatial_dissim_index.statistic</span>
<span class="sd">    0.2866269198707091</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Morrill, R. L. (1991) &quot;On the Measure of Geographic Segregation&quot;. Geography Research Forum.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morrill1991measure`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpatialDissim.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialDissim.html#segregation.spatial.SpatialDissim.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span>
                              <span class="n">standardize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_dissim</span></div></div>


<span class="k">def</span> <span class="nf">_boundary_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">group_pop_var</span><span class="p">,</span>
                             <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Boundary Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default without row standardization. That is, directly with border length.</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Boundary Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The formula is based on Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">    </span>
<span class="sd">    Original paper by Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    References: :cite:`hong2014implementing` and :cite:`wong1993spatial`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;std is not a boolean object&#39;</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="c1"># If a unit has zero population, the group of interest frequency is zero</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
        <span class="n">pi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span> <span class="o">/</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">cij</span> <span class="o">/</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">cij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># manhattan_distances used to compute absolute distances</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">manhattan_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pi&#39;</span><span class="p">]]),</span> <span class="n">cij</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">den</span> <span class="o">=</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">BSD</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="n">num</span> <span class="o">/</span> <span class="n">den</span>
    <span class="n">BSD</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">BSD</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="BoundarySpatialDissim"><a class="viewcode-back" href="../../../generated/segregation.spatial.BoundarySpatialDissim.html#segregation.spatial.BoundarySpatialDissim">[docs]</a><span class="k">class</span> <span class="nc">BoundarySpatialDissim</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Boundary Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for row standardisation of the weights matrices. If True, the values of cij in the formulas gets row standardized.</span>
<span class="sd">                    For the sake of comparison, the seg R package of Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">                    works by default without row standardization. That is, directly with border length.</span>
<span class="sd">        </span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Boundary Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">         </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of boundary spatial dissimilarity (D) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import BoundarySpatialDissim</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; boundary_spatial_dissim_index = BoundarySpatialDissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; boundary_spatial_dissim_index.statistic</span>
<span class="sd">    0.28869903953453163</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The formula is based on Hong, Seong-Yun, David O&#39;Sullivan, and Yukio Sadahiro. &quot;Implementing spatial segregation measures in R.&quot; PloS one 9.11 (2014): e113767.</span>
<span class="sd">    </span>
<span class="sd">    Original paper by Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    References: :cite:`hong2014implementing` and :cite:`wong1993spatial`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="BoundarySpatialDissim.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.BoundarySpatialDissim.html#segregation.spatial.BoundarySpatialDissim.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_boundary_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">standardize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_boundary_spatial_dissim</span></div></div>


<span class="k">def</span> <span class="nf">_perimeter_area_ratio_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                                         <span class="n">group_pop_var</span><span class="p">,</span>
                                         <span class="n">total_pop_var</span><span class="p">,</span>
                                         <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Perimeter/Area Ratio Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for standardisation of the weights matrices. </span>
<span class="sd">                    If True, the values of cij in the formulas gets standardized and the overall sum is 1.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Perimeter/Area Ratio Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Originally based on Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    However, Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>
<span class="sd">    points out that in Wong’s original there is an issue with the formula which is an extra division by 2 in the spatial interaction component.</span>
<span class="sd">    This function follows the formula present in the first Appendix of Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>

<span class="sd">    References: :cite:`wong1993spatial` and :cite:`tivadar2019oasisr`.</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">standardize</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;std is not a boolean object&#39;</span><span class="p">)</span>

    <span class="n">D</span> <span class="o">=</span> <span class="n">_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="c1"># If a unit has zero population, the group of interest frequency is zero</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span>
        <span class="n">pi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span> <span class="o">/</span>
                    <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">standardize</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">_return_length_weighted_w</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">full</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">cij</span> <span class="o">=</span> <span class="n">cij</span> <span class="o">/</span> <span class="n">cij</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">peri</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">length</span>
    <span class="n">ai</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span>

    <span class="n">aux_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">))),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">)))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">))),</span> <span class="mi">1</span><span class="p">)))</span>

    <span class="n">max_pa</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">peri</span> <span class="o">/</span> <span class="n">ai</span><span class="p">)</span>

    <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">manhattan_distances</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="s1">&#39;pi&#39;</span><span class="p">]]),</span> <span class="n">cij</span><span class="p">),</span>
                      <span class="n">aux_sum</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">den</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">max_pa</span>

    <span class="n">PARD</span> <span class="o">=</span> <span class="n">D</span> <span class="o">-</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">den</span><span class="p">)</span>
    <span class="n">PARD</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">PARD</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="PerimeterAreaRatioSpatialDissim"><a class="viewcode-back" href="../../../generated/segregation.spatial.PerimeterAreaRatioSpatialDissim.html#segregation.spatial.PerimeterAreaRatioSpatialDissim">[docs]</a><span class="k">class</span> <span class="nc">PerimeterAreaRatioSpatialDissim</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Perimeter/Area Ratio Spatial Dissimilarity index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    standardize   : boolean</span>
<span class="sd">                    A condition for standardisation of the weights matrices. </span>
<span class="sd">                    If True, the values of cij in the formulas gets standardized and the overall sum is 1.</span>
<span class="sd">        </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Perimeter/Area Ratio Spatial Dissimilarity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.      </span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of perimeter/area ratio spatial dissimilarity (PARD) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import PerimeterAreaRatioSpatialDissim</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; perimeter_area_ratio_spatial_dissim_index = PerimeterAreaRatioSpatialDissim(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; perimeter_area_ratio_spatial_dissim_index.statistic</span>
<span class="sd">    0.31260876347432687</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Originally based on Wong, David WS. &quot;Spatial indices of segregation.&quot; Urban studies 30.3 (1993): 559-572.</span>
<span class="sd">    </span>
<span class="sd">    However, Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>
<span class="sd">    points out that in Wong’s original there is an issue with the formula which is an extra division by 2 in the spatial interaction component.</span>
<span class="sd">    This function follows the formula present in the first Appendix of Tivadar, Mihai. &quot;OasisR: An R Package to Bring Some Order to the World of Segregation Measurement.&quot; Journal of Statistical Software 89.1 (2019): 1-39.</span>
<span class="sd">    </span>
<span class="sd">    References: :cite:`wong1993spatial` and :cite:`tivadar2019oasisr`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PerimeterAreaRatioSpatialDissim.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.PerimeterAreaRatioSpatialDissim.html#segregation.spatial.PerimeterAreaRatioSpatialDissim.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">standardize</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_perimeter_area_ratio_spatial_dissim</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span>
                                                   <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">standardize</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_perimeter_area_ratio_spatial_dissim</span></div></div>
        


<div class="viewcode-block" id="SpatialMinMax"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialMinMax.html#segregation.spatial.SpatialMinMax">[docs]</a><span class="k">class</span> <span class="nc">SpatialMinMax</span><span class="p">(</span><span class="n">MinMax</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spatial MinMax Index.</span>

<span class="sd">    This class calculates the spatial version of the MinMax</span>
<span class="sd">    index. The data are &quot;spatialized&quot; by converting each observation</span>
<span class="sd">    to a &quot;local environment&quot; by creating a weighted sum of the focal unit with</span>
<span class="sd">    its neighboring observations, where the neighborhood is defined by a</span>
<span class="sd">    libpysal weights matrix or a pandana Network instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : geopandas.GeoDataFrame</span>
<span class="sd">        geodataframe with</span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">        The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">        The name of variable in data that contains the total population of the unit</span>
<span class="sd">    w   : libpysal.W</span>
<span class="sd">        distance-based PySAL spatial weights matrix instance</span>
<span class="sd">    network : pandana.Network</span>
<span class="sd">        pandana.Network instance. This is likely created with `get_osm_network`</span>
<span class="sd">        or via helper functions from OSMnet or UrbanAccess.</span>
<span class="sd">    distance : int</span>
<span class="sd">        maximum distance to consider `accessible` (the default is 2000).</span>
<span class="sd">    decay : str</span>
<span class="sd">        decay type pandana should use &quot;linear&quot;, &quot;exp&quot;, or &quot;flat&quot;</span>
<span class="sd">        (which means no decay). The default is &quot;linear&quot;.</span>
<span class="sd">    precompute: bool</span>
<span class="sd">        Whether the pandana.Network instance should precompute the range</span>
<span class="sd">        queries.This is true by default, but if you plan to calculate several</span>
<span class="sd">        indices using the same network, then you can set this</span>
<span class="sd">        parameter to `False` to avoid precomputing repeatedly inside the</span>
<span class="sd">        function</span>
<span class="sd">        </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                SpatialMinMax Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a pandas DataFrame</span>
<span class="sd">                A pandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on O&#39;Sullivan &amp; Wong (2007). A Surface‐Based Approach to Measuring Spatial Segregation.</span>
<span class="sd">    Geographical Analysis 39 (2). https://doi.org/10.1111/j.1538-4632.2007.00699.x</span>

<span class="sd">    Reference: :cite:`osullivanwong2007surface`.</span>
<span class="sd">    </span>
<span class="sd">    We&#39;d like to thank @AnttiHaerkoenen for this contribution!</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpatialMinMax.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialMinMax.html#segregation.spatial.SpatialMinMax.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">data</span><span class="p">,</span> 
                 <span class="n">group_pop_var</span><span class="p">,</span> 
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">decay</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                 <span class="n">precompute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> 
                                    <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">})</span>
    
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_2_pop_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;total_pop_var&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span>
        
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;group_2_pop_var&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">network</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">Kernel</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">w</span> <span class="ow">and</span> <span class="n">network</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span>
                <span class="s2">&quot;must pass either a pandana network or a pysal weights object</span><span class="se">\</span>
<span class="s2">                 but not both&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">network</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calc_access</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">variables</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                             <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span>
                             <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                             <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">,</span>
                             <span class="n">precompute</span><span class="o">=</span><span class="n">precompute</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;acc_&quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">_build_local_environment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;resulting_total&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;group_2_pop_var&#39;</span><span class="p">]</span>
        
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;resulting_total&#39;</span><span class="p">)</span></div></div>



<span class="k">def</span> <span class="nf">_distance_decay_isolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                              <span class="n">group_pop_var</span><span class="p">,</span>
                              <span class="n">total_pop_var</span><span class="p">,</span>
                              <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                              <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                              <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Distance Decay Isolation index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Distance Decay Isolation Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It may be interpreted as the probability that the next person a group member meets anywhere in space is from the same group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>  <span class="c1"># This needs to be latitude first!</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine accurately the exponential of the negative distances. This is probably due to the large magnitude of the centroids numbers. It is recommended to reproject the geopandas DataFrame. Also, if this is a not lat-long CRS, it is recommended to set metric to </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">)))</span>
    
    <span class="n">Pij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">DDxPx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span> <span class="o">*</span>
             <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">Pij</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">t</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">DDxPx</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="DistanceDecayIsolation"><a class="viewcode-back" href="../../../generated/segregation.spatial.DistanceDecayIsolation.html#segregation.spatial.DistanceDecayIsolation">[docs]</a><span class="k">class</span> <span class="nc">DistanceDecayIsolation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Distance Decay Isolation index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Distance Decay Isolation Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the distance decay isolation index (DDxPx) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import DistanceDecayIsolation</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_isolation_index = DistanceDecayIsolation(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_isolation_index.statistic</span>
<span class="sd">    0.07214112078134231</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It may be interpreted as the probability that the next person a group member meets anywhere in space is from the same group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DistanceDecayIsolation.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.DistanceDecayIsolation.html#segregation.spatial.DistanceDecayIsolation.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_distance_decay_isolation</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                        <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_distance_decay_isolation</span></div></div>


<span class="k">def</span> <span class="nf">_distance_decay_exposure</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">group_pop_var</span><span class="p">,</span>
                             <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                             <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                             <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Distance Decay Exposure index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Distance Decay Exposure Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It may be interpreted as the probability that the next person a group member meets anywhere in space is from the other group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">x</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>  <span class="c1"># This needs to be latitude first!</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine accurately the exponential of the negative distances. This is probably due to the large magnitude of the centroids numbers. It is recommended to reproject the geopandas DataFrame. Also, if this is a not lat-long CRS, it is recommended to set metric to </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">)))</span>
    
    <span class="n">Pij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">DDxPy</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">X</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">Pij</span><span class="p">,</span> <span class="n">y</span> <span class="o">/</span> <span class="n">t</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">DDxPy</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="DistanceDecayExposure"><a class="viewcode-back" href="../../../generated/segregation.spatial.DistanceDecayExposure.html#segregation.spatial.DistanceDecayExposure">[docs]</a><span class="k">class</span> <span class="nc">DistanceDecayExposure</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Distance Decay Exposure index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Distance Decay Exposure Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the distance decay exposure index (DDxPy) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import DistanceDecayExposure</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_exposure_index = DistanceDecayExposure(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_exposure_index.statistic</span>
<span class="sd">    0.9605053172501217</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    It may be interpreted as the probability that the next person a group member meets anywhere in space is from the other group.</span>
<span class="sd">    </span>
<span class="sd">    Based on Morgan, Barrie S. &quot;A distance-decay based interaction index to measure residential segregation.&quot; Area (1983): 211-217.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`morgan1983distance`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="DistanceDecayExposure.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.DistanceDecayExposure.html#segregation.spatial.DistanceDecayExposure.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_distance_decay_exposure</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_distance_decay_exposure</span></div></div>


<span class="k">def</span> <span class="nf">_spatial_proximity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                       <span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">total_pop_var</span><span class="p">,</span>
                       <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                       <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                       <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">T</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">xi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">yi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">ti</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>  <span class="c1"># This needs to be latitude first!</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine accurately the exponential of the negative distances. This is probably due to the large magnitude of the centroids numbers. It is recommended to reproject the geopandas DataFrame. Also, if this is a not lat-long CRS, it is recommended to set metric to </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">)))</span>
    
    <span class="n">Pxx</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">X</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Pyy</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Ptt</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ti</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">ti</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">SP</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">Pxx</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">Pyy</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="n">Ptt</span><span class="p">)</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">SP</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="SpatialProximity"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialProximity.html#segregation.spatial.SpatialProximity">[docs]</a><span class="k">class</span> <span class="nc">SpatialProximity</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Spatial Proximity index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>
<span class="sd">                    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Spatial Proximity Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the degree of spatial proximity (SP) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import SpatialProximity</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; spatial_prox_index = SpatialProximity(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; spatial_prox_index.statistic</span>
<span class="sd">    1.002191883006537</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpatialProximity.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.SpatialProximity.html#segregation.spatial.SpatialProximity.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_spatial_proximity</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                 <span class="n">beta</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_spatial_proximity</span></div></div>


<span class="k">def</span> <span class="nf">_absolute_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                         <span class="n">group_pop_var</span><span class="p">,</span>
                         <span class="n">total_pop_var</span><span class="p">,</span>
                         <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                         <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">xi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">yi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>  <span class="c1"># This needs to be latitude first!</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine accurately the exponential of the negative distances. This is probably due to the large magnitude of the centroids numbers. It is recommended to reproject the geopandas DataFrame. Also, if this is a not lat-long CRS, it is recommended to set metric to </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">)))</span>
    
    <span class="n">ACL</span> <span class="o">=</span> <span class="p">((((</span><span class="n">x</span><span class="o">/</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">X</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">/</span> \
          <span class="p">((((</span><span class="n">x</span><span class="o">/</span><span class="n">X</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">X</span> <span class="o">/</span> <span class="n">n</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">ACL</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="AbsoluteClustering"><a class="viewcode-back" href="../../../generated/segregation.spatial.AbsoluteClustering.html#segregation.spatial.AbsoluteClustering">[docs]</a><span class="k">class</span> <span class="nc">AbsoluteClustering</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>
<span class="sd">                    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the absolute clustering measure (ACL) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;trtid10&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;trtid10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; absolute_clust_index = Absolute_Clustering(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; absolute_clust_index.statistic</span>
<span class="sd">    0.20979814508119624</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbsoluteClustering.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.AbsoluteClustering.html#segregation.spatial.AbsoluteClustering.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_absolute_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                   <span class="n">beta</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_absolute_clustering</span></div></div>


<span class="k">def</span> <span class="nf">_relative_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                         <span class="n">group_pop_var</span><span class="p">,</span>
                         <span class="n">total_pop_var</span><span class="p">,</span>
                         <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                         <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                         <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>
<span class="sd">                    </span>
<span class="sd">    Returns</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Relative Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;alpha must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">beta</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;beta must be greater than zero.&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">xi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">,</span>
                       <span class="n">yi</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">euclidean_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">haversine_distances</span><span class="p">(</span>
            <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
                <span class="s1">&#39;c_lats&#39;</span><span class="p">:</span> <span class="n">c_lats</span><span class="p">,</span>
                <span class="s1">&#39;c_lons&#39;</span><span class="p">:</span> <span class="n">c_lons</span>
            <span class="p">}))</span>  <span class="c1"># This needs to be latitude first!</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">dist</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">):</span> 
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine accurately the exponential of the negative distances. This is probably due to the large magnitude of the centroids numbers. It is recommended to reproject the geopandas DataFrame. Also, if this is a not lat-long CRS, it is recommended to set metric to </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">beta</span><span class="p">)))</span>
    
    <span class="n">Pxx</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">xi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">X</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Pyy</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">yi</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">Y</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">RCL</span> <span class="o">=</span> <span class="n">Pxx</span> <span class="o">/</span> <span class="n">Pyy</span> <span class="o">-</span> <span class="mi">1</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">RCL</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine the distance between, at least, one pair of units. This is probably due to the magnitude of the number of the centroids. We recommend to reproject the geopandas DataFrame.&#39;</span><span class="p">)</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">RCL</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="RelativeClustering"><a class="viewcode-back" href="../../../generated/segregation.spatial.RelativeClustering.html#segregation.spatial.RelativeClustering">[docs]</a><span class="k">class</span> <span class="nc">RelativeClustering</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Clustering index</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    alpha         : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.6</span>
<span class="sd">    </span>
<span class="sd">    beta          : float</span>
<span class="sd">                    A parameter that estimates the extent of the proximity within the same unit. Default value is 0.5</span>
<span class="sd">                    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>
<span class="sd">                    </span>
<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    statistic : float</span>
<span class="sd">                Relative Clustering Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the relative clustering measure (RCL) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import RelativeClustering</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; relative_clust_index = RelativeClustering(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; relative_clust_index.statistic</span>
<span class="sd">    0.12418089857347714</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    The pairwise distance between unit i and itself is (alpha * area_of_unit_i) ^ beta.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RelativeClustering.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.RelativeClustering.html#segregation.spatial.RelativeClustering.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
                 <span class="n">beta</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_relative_clustering</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span>
                                   <span class="n">beta</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_relative_clustering</span></div></div>


<span class="k">def</span> <span class="nf">_delta</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Delta index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Delta Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">DEL</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">X</span> <span class="o">-</span> <span class="n">area</span> <span class="o">/</span> <span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">DEL</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="Delta"><a class="viewcode-back" href="../../../generated/segregation.spatial.Delta.html#segregation.spatial.Delta">[docs]</a><span class="k">class</span> <span class="nc">Delta</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Delta index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Delta Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the delta index (D) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import Delta</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; delta_index = Delta(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; delta_index.statistic</span>
<span class="sd">    0.8367330649317353</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Delta.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.Delta.html#segregation.spatial.Delta.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_delta</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_delta</span></div></div>


<span class="k">def</span> <span class="nf">_absolute_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Create the indexes according to the area ordering</span>
    <span class="n">des_ind</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">area</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="c1"># A discussion about the extraction of n1 and n2 can be found in https://github.com/pysal/segregation/issues/43</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n2_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">des_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">n2_aux</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">ACO</span> <span class="o">=</span> <span class="mi">1</span><span class="o">-</span> <span class="p">((((</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">T1</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">/</span> \
          <span class="p">(((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">T2</span><span class="p">)[</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">-</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span><span class="o">/</span><span class="n">T1</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">())))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">ACO</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="AbsoluteConcentration"><a class="viewcode-back" href="../../../generated/segregation.spatial.AbsoluteConcentration.html#segregation.spatial.AbsoluteConcentration">[docs]</a><span class="k">class</span> <span class="nc">AbsoluteConcentration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Absolute Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the absolute concentration index (ACO) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import AbsoluteConcentration</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; absolute_concentration_index = AbsoluteConcentration(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; absolute_concentration_index.statistic</span>
<span class="sd">    0.9577607171503524</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbsoluteConcentration.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.AbsoluteConcentration.html#segregation.spatial.AbsoluteConcentration.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_absolute_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_absolute_concentration</span></div></div>


<span class="k">def</span> <span class="nf">_relative_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>

<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Relative Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">x</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># Create the indexes according to the area ordering</span>
    <span class="n">des_ind</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">area</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="c1"># A discussion about the extraction of n1 and n2 can be found in https://github.com/pysal/segregation/issues/43</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n2_aux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">des_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">X</span> <span class="o">/</span> <span class="n">T</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">n2_aux</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">T1</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">T2</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">][</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">RCO</span> <span class="o">=</span> <span class="p">((((</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="o">/</span> <span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">/</span> <span class="n">Y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> \
          <span class="p">((((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])[</span><span class="mi">0</span><span class="p">:</span><span class="n">n1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T1</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">t</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">]</span> <span class="o">*</span> <span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])[</span><span class="n">n2</span><span class="p">:</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">T2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">RCO</span><span class="p">,</span> <span class="n">core_data</span>


<div class="viewcode-block" id="RelativeConcentration"><a class="viewcode-back" href="../../../generated/segregation.spatial.RelativeConcentration.html#segregation.spatial.RelativeConcentration">[docs]</a><span class="k">class</span> <span class="nc">RelativeConcentration</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Concentration index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic : float</span>
<span class="sd">                Relative Concentration Index</span>
<span class="sd">                </span>
<span class="sd">    core_data : a geopandas DataFrame</span>
<span class="sd">                A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">       </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the relative concentration index (RCO) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import RelativeConcentration</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; relative_concentration_index = RelativeConcentration(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; relative_concentration_index.statistic</span>
<span class="sd">    0.5204046784837685</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RelativeConcentration.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.RelativeConcentration.html#segregation.spatial.RelativeConcentration.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_relative_concentration</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_relative_concentration</span></div></div>


<span class="k">def</span> <span class="nf">_absolute_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">group_pop_var</span><span class="p">,</span>
                             <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                             <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Absolute Centralization Index</span>
<span class="sd">                </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">area</span><span class="p">)</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;population_weighted_mean&#39;</span><span class="p">,</span>
                <span class="s1">&#39;largest_population&#39;</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The center string must one of </span><span class="se">\&#39;</span><span class="s1">mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">median</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">population_weighted_mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">largest_population</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lons</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lats</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;population_weighted_mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lons</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lats</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;largest_population&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center tuple/list/array must have length 2.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center index must by in the range of data.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">area</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">dlon</span> <span class="o">=</span> <span class="n">c_lons</span> <span class="o">-</span> <span class="n">center_lon</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">c_lats</span> <span class="o">-</span> <span class="n">center_lat</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">center_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dlon</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dlat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">center_dist</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">center_lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c_lats</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">center_dist</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine the center distance for, at least, one unit. This is probably due to the magnitude of the number of the centroids. We recommend to reproject the geopandas DataFrame.&#39;</span><span class="p">)</span>
    
    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">center_dist</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">Xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">Ai</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">area</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">A</span>

    <span class="n">ACE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">shift</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ai</span><span class="p">)</span> <span class="o">-</span> \
          <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Xi</span> <span class="o">*</span> <span class="n">shift</span><span class="p">(</span><span class="n">Ai</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="n">center_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">center_lon</span><span class="p">,</span> <span class="n">center_lat</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">ACE</span><span class="p">,</span> <span class="n">core_data</span><span class="p">,</span> <span class="n">center_values</span>


<div class="viewcode-block" id="AbsoluteCentralization"><a class="viewcode-back" href="../../../generated/segregation.spatial.AbsoluteCentralization.html#segregation.spatial.AbsoluteCentralization">[docs]</a><span class="k">class</span> <span class="nc">AbsoluteCentralization</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Absolute Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>
<span class="sd">                    </span>
<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Absolute Centralization Index</span>
<span class="sd">                </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the absolute centralization index (ACE) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import AbsoluteCentralization</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; absolute_centralization_index = AbsoluteCentralization(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; absolute_centralization_index.statistic</span>
<span class="sd">    0.6416113799795511</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AbsoluteCentralization.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.AbsoluteCentralization.html#segregation.spatial.AbsoluteCentralization.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_absolute_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">center</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_values</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_absolute_centralization</span></div></div>


<span class="k">def</span> <span class="nf">_relative_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">group_pop_var</span><span class="p">,</span>
                             <span class="n">total_pop_var</span><span class="p">,</span>
                             <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                             <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>

<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Relative Centralization Index</span>
<span class="sd">                </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">metric</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span> <span class="s1">&#39;haversine&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;metric must one of </span><span class="se">\&#39;</span><span class="s1">euclidean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">haversine</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">!=</span> <span class="s1">&#39;&lt;class </span><span class="se">\&#39;</span><span class="s1">geopandas.geodataframe.GeoDataFrame</span><span class="se">\&#39;</span><span class="s1">&gt;&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s1">&#39;data is not a GeoDataFrame and, therefore, this index cannot be calculated.&#39;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;geometry&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
        <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="nb">type</span><span class="p">(</span><span class="n">group_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">total_pop_var</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;group_pop_var and total_pop_var must be strings&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">group_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="ow">or</span> <span class="p">(</span><span class="n">total_pop_var</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;group_pop_var and total_pop_var must be variables of data&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span>
        <span class="n">group_pop_var</span><span class="p">:</span> <span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span>
        <span class="n">total_pop_var</span><span class="p">:</span> <span class="s1">&#39;total_pop_var&#39;</span>
    <span class="p">})</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">group_pop_var</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">total_pop_var</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;Group of interest population must equal or lower than the total population of the units.&#39;</span>
        <span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">x</span>

    <span class="n">c_lons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    <span class="n">c_lats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">center</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;population_weighted_mean&#39;</span><span class="p">,</span>
                <span class="s1">&#39;largest_population&#39;</span>
        <span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The center string must one of </span><span class="se">\&#39;</span><span class="s1">mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">median</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">population_weighted_mean</span><span class="se">\&#39;</span><span class="s1">, </span><span class="se">\&#39;</span><span class="s1">largest_population</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lons</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">c_lats</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;population_weighted_mean&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lons</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">c_lats</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">t</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">==</span> <span class="s2">&quot;largest_population&quot;</span><span class="p">):</span>
            <span class="n">center_lon</span> <span class="o">=</span> <span class="n">c_lons</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">center_lat</span> <span class="o">=</span> <span class="n">c_lats</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">())]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">center</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">center</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center tuple/list/array must have length 2.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">center</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The center index must by in the range of data.&#39;</span><span class="p">)</span>

        <span class="n">center_lon</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">center_lat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">center</span><span class="p">]]</span><span class="o">.</span><span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">dlon</span> <span class="o">=</span> <span class="n">c_lons</span> <span class="o">-</span> <span class="n">center_lon</span>
    <span class="n">dlat</span> <span class="o">=</span> <span class="n">c_lats</span> <span class="o">-</span> <span class="n">center_lat</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        <span class="n">center_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">dlon</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">dlat</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">metric</span> <span class="o">==</span> <span class="s1">&#39;haversine&#39;</span><span class="p">):</span>
        <span class="n">center_dist</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlat</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">center_lat</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">c_lats</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dlon</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">center_dist</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It not possible to determine the center distance for, at least, one unit. This is probably due to the magnitude of the number of the centroids. We recommend to reproject the geopandas DataFrame.&#39;</span><span class="p">)</span>

    <span class="n">asc_ind</span> <span class="o">=</span> <span class="n">center_dist</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>

    <span class="n">Xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">X</span>
    <span class="n">Yi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">asc_ind</span><span class="p">])</span> <span class="o">/</span> <span class="n">Y</span>

    <span class="n">RCE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">shift</span><span class="p">(</span><span class="n">Xi</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">)</span> <span class="o">*</span> <span class="n">Yi</span><span class="p">)</span> <span class="o">-</span> \
          <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">Xi</span> <span class="o">*</span> <span class="n">shift</span><span class="p">(</span><span class="n">Yi</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">))</span>

    <span class="n">core_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[[</span><span class="s1">&#39;group_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;total_pop_var&#39;</span><span class="p">,</span> <span class="s1">&#39;geometry&#39;</span><span class="p">]]</span>

    <span class="n">center_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">center_lon</span><span class="p">,</span> <span class="n">center_lat</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">RCE</span><span class="p">,</span> <span class="n">core_data</span><span class="p">,</span> <span class="n">center_values</span>


<div class="viewcode-block" id="RelativeCentralization"><a class="viewcode-back" href="../../../generated/segregation.spatial.RelativeCentralization.html#segregation.spatial.RelativeCentralization">[docs]</a><span class="k">class</span> <span class="nc">RelativeCentralization</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculation of Relative Centralization index</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>

<span class="sd">    data          : a geopandas DataFrame with a geometry column.</span>
<span class="sd">    </span>
<span class="sd">    group_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the population size of the group of interest</span>
<span class="sd">                    </span>
<span class="sd">    total_pop_var : string</span>
<span class="sd">                    The name of variable in data that contains the total population of the unit</span>

<span class="sd">    center        : string, two-dimension values (tuple, list, array) or integer.</span>
<span class="sd">                    This defines what is considered to be the center of the spatial context under study.</span>

<span class="sd">                    If string, this can be set to:</span>
<span class="sd">                        </span>
<span class="sd">                        &quot;mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;median&quot;: the center longitude/latitude is the median of longitudes/latitudes of all units. </span>
<span class="sd">                        &quot;population_weighted_mean&quot;: the center longitude/latitude is the mean of longitudes/latitudes of all units weighted by the total population.</span>
<span class="sd">                        &quot;largest_population&quot;: the center longitude/latitude is the centroid of the unit with largest total population. If there is a tie in the maximum population, the mean of all coordinates will be taken.</span>
<span class="sd">                    </span>
<span class="sd">                    If tuple, list or array, this argument should be the coordinates of the desired center assuming longitude as first value and latitude second value. Therefore, in the form (longitude, latitude), if tuple, or [longitude, latitude] if list or numpy array.</span>
<span class="sd">                    </span>
<span class="sd">                    If integer, the center will be the centroid of the polygon from data corresponding to the integer interpreted as index. </span>
<span class="sd">                    For example, if `center = 0` the centroid of the first row of data is used as center, if `center = 1` the second row will be used, and so on.</span>
<span class="sd">    </span>
<span class="sd">    metric        : string. Can be &#39;euclidean&#39; or &#39;haversine&#39;. Default is &#39;euclidean&#39;.</span>
<span class="sd">                    The metric used for the distance between spatial units. </span>
<span class="sd">                    If the projection of the CRS of the geopandas DataFrame field is in degrees, this should be set to &#39;haversine&#39;.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>

<span class="sd">    statistic     : float</span>
<span class="sd">                    Relative Centralization Index</span>
<span class="sd">            </span>
<span class="sd">    core_data     : a geopandas DataFrame</span>
<span class="sd">                    A geopandas DataFrame that contains the columns used to perform the estimate.</span>
<span class="sd">    </span>
<span class="sd">    center_values : list</span>
<span class="sd">                    The center, in the form [longitude, latitude], values used for the calculation of the centralization distances.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    In this example, we will calculate the relative centralization index (RCE) for the Riverside County using the census tract data of 2010.</span>
<span class="sd">    The group of interest is non-hispanic black people which is the variable nhblk10 in the dataset.</span>
<span class="sd">    </span>
<span class="sd">    Firstly, we need to perform some import the modules and the respective function.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; import pandas as pd</span>
<span class="sd">    &gt;&gt;&gt; import geopandas as gpd</span>
<span class="sd">    &gt;&gt;&gt; import segregation</span>
<span class="sd">    &gt;&gt;&gt; from segregation.spatial import RelativeCentralization</span>
<span class="sd">    </span>
<span class="sd">    Secondly, we need to read the data:</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # This example uses all census data that the user must provide your own copy of the external database.</span>
<span class="sd">    &gt;&gt;&gt; # A step-by-step procedure for downloading the data can be found here: https://github.com/spatialucr/geosnap/blob/master/examples/01_getting_started.ipynb</span>
<span class="sd">    &gt;&gt;&gt; # After the user download the LTDB_Std_All_fullcount.zip and extract the files, the filepath might be something like presented below.</span>
<span class="sd">    &gt;&gt;&gt; filepath = &#39;~/data/LTDB_Std_2010_fullcount.csv&#39;</span>
<span class="sd">    &gt;&gt;&gt; census_2010 = pd.read_csv(filepath, encoding = &quot;ISO-8859-1&quot;, sep = &quot;,&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Then, we filter only for the desired county (in this case, Riverside County):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; df = census_2010.loc[census_2010.county == &quot;Riverside County&quot;][[&#39;tractid&#39;, &#39;pop10&#39;,&#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    Then, we read the Riverside map data using geopandas (the county id is 06065):</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_url = &#39;https://raw.githubusercontent.com/renanxcortes/inequality-segregation-supplementary-files/master/Tracts_grouped_by_County/06065.json&#39;</span>
<span class="sd">    &gt;&gt;&gt; map_gpd = gpd.read_file(map_url)</span>
<span class="sd">    </span>
<span class="sd">    It is necessary to harmonize the data type of the dataset and the geopandas in order to work the merging procedure.</span>
<span class="sd">    Later, we extract only the columns that will be used.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; map_gpd[&#39;INTGEOID10&#39;] = pd.to_numeric(map_gpd[&quot;GEOID10&quot;])</span>
<span class="sd">    &gt;&gt;&gt; gdf_pre = map_gpd.merge(df, left_on = &#39;INTGEOID10&#39;, right_on = &#39;tractid&#39;)</span>
<span class="sd">    &gt;&gt;&gt; gdf = gdf_pre[[&#39;geometry&#39;, &#39;pop10&#39;, &#39;nhblk10&#39;]]</span>
<span class="sd">    </span>
<span class="sd">    The value is estimated below.</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; relative_centralization_index = RelativeCentralization(gdf, &#39;nhblk10&#39;, &#39;pop10&#39;)</span>
<span class="sd">    &gt;&gt;&gt; relative_centralization_index.statistic</span>
<span class="sd">    0.18550429720565376</span>
<span class="sd">            </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Massey, Douglas S., and Nancy A. Denton. &quot;The dimensions of residential segregation.&quot; Social forces 67.2 (1988): 281-315.</span>
<span class="sd">    </span>
<span class="sd">    A discussion of defining the center in this function can be found in https://github.com/pysal/segregation/issues/18.</span>
<span class="sd">    </span>
<span class="sd">    Reference: :cite:`massey1988dimensions`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="RelativeCentralization.__init__"><a class="viewcode-back" href="../../../generated/segregation.spatial.RelativeCentralization.html#segregation.spatial.RelativeCentralization.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">group_pop_var</span><span class="p">,</span>
                 <span class="n">total_pop_var</span><span class="p">,</span>
                 <span class="n">center</span><span class="o">=</span><span class="s2">&quot;mean&quot;</span><span class="p">,</span>
                 <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">):</span>
        
        <span class="n">data</span> <span class="o">=</span> <span class="n">_nan_handle</span><span class="p">(</span><span class="n">data</span><span class="p">[[</span><span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">_geometry_column_name</span><span class="p">]])</span>

        <span class="n">aux</span> <span class="o">=</span> <span class="n">_relative_centralization</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">group_pop_var</span><span class="p">,</span> <span class="n">total_pop_var</span><span class="p">,</span>
                                       <span class="n">center</span><span class="p">,</span> <span class="n">metric</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">statistic</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_data</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_values</span> <span class="o">=</span> <span class="n">aux</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function</span> <span class="o">=</span> <span class="n">_relative_centralization</span></div></div>


<span class="k">class</span> <span class="nc">SpatialInformationTheory</span><span class="p">(</span><span class="n">MultiInformationTheory</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spatial Multigroup Information Theory Index.</span>

<span class="sd">    This class calculates the spatial version of the multigroup information</span>
<span class="sd">    theory index. The data are &quot;spatialized&quot; by converting each observation</span>
<span class="sd">    to a &quot;local environment&quot; by creating a weighted sum of the focal unit with</span>
<span class="sd">    its neighboring observations, where the neighborhood is defined by a</span>
<span class="sd">    libpysal weights matrix or a pandana Network instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : geopandas.GeoDataFrame</span>
<span class="sd">        geodataframe with</span>
<span class="sd">    groups : list</span>
<span class="sd">        list of columns on gdf representing population groups for which the SIT</span>
<span class="sd">        index should be calculated</span>
<span class="sd">    network : pandana.Network</span>
<span class="sd">        pandana.Network instance. This is likely created with `get_osm_network`</span>
<span class="sd">        or via helper functions from OSMnet or UrbanAccess.</span>
<span class="sd">    w   : libpysal.W</span>
<span class="sd">        distance-based PySAL spatial weights matrix instance</span>
<span class="sd">    distance : int</span>
<span class="sd">        maximum distance to consider `accessible` (the default is 2000).</span>
<span class="sd">    decay : str</span>
<span class="sd">        decay type pandana should use &quot;linear&quot;, &quot;exp&quot;, or &quot;flat&quot;</span>
<span class="sd">        (which means no decay). The default is &quot;linear&quot;.</span>
<span class="sd">    precompute: bool</span>
<span class="sd">        Whether the pandana.Network instance should precompute the range</span>
<span class="sd">        queries.This is true by default, but if you plan to calculate several</span>
<span class="sd">        indices using the same network, then you can set this</span>
<span class="sd">        parameter to `False` to avoid precomputing repeatedly inside the</span>
<span class="sd">        function</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">groups</span><span class="p">,</span>
                 <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">decay</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                 <span class="n">precompute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">w</span> <span class="ow">and</span> <span class="n">network</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span>
                <span class="s2">&quot;must pass either a pandana network or a pysal weights object</span><span class="se">\</span>
<span class="s2">                 but not both&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">network</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calc_access</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">variables</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                             <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span>
                             <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                             <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">,</span>
                             <span class="n">precompute</span><span class="o">=</span><span class="n">precompute</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;acc_&quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">_build_local_environment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">groups</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SpatialDivergence</span><span class="p">(</span><span class="n">MultiDivergence</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Spatial Multigroup Divergence Index.</span>

<span class="sd">    This class calculates the spatial version of the multigroup divergence</span>
<span class="sd">    index. The data are &quot;spatialized&quot; by converting each observation</span>
<span class="sd">    to a &quot;local environment&quot; by creating a weighted sum of the focal unit with</span>
<span class="sd">    its neighboring observations, where the neighborhood is defined by a</span>
<span class="sd">    libpysal weights matrix or a pandana Network instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : geopandas.GeoDataFrame</span>
<span class="sd">        geodataframe with</span>
<span class="sd">    groups : list</span>
<span class="sd">        list of columns on gdf representing population groups for which the</span>
<span class="sd">        divergence index should be calculated</span>
<span class="sd">    w   : libpysal.W</span>
<span class="sd">        distance-based PySAL spatial weights matrix instance</span>
<span class="sd">    network : pandana.Network</span>
<span class="sd">        pandana.Network instance. This is likely created with `get_osm_network`</span>
<span class="sd">        or via helper functions from OSMnet or UrbanAccess.</span>
<span class="sd">    distance : int</span>
<span class="sd">        maximum distance to consider `accessible` (the default is 2000).</span>
<span class="sd">    decay : str</span>
<span class="sd">        decay type pandana should use &quot;linear&quot;, &quot;exp&quot;, or &quot;flat&quot;</span>
<span class="sd">        (which means no decay). The default is &quot;linear&quot;.</span>
<span class="sd">    precompute: bool</span>
<span class="sd">        Whether the pandana.Network instance should precompute the range</span>
<span class="sd">        queries.This is true by default, but if you plan to calculate several</span>
<span class="sd">        indices using the same network, then you can set this</span>
<span class="sd">        parameter to `False` to avoid precomputing repeatedly inside the</span>
<span class="sd">        function</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">data</span><span class="p">,</span>
                 <span class="n">groups</span><span class="p">,</span>
                 <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">w</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">decay</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                 <span class="n">distance</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span>
                 <span class="n">precompute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">w</span> <span class="ow">and</span> <span class="n">network</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span>
                <span class="s2">&quot;must pass either a pandana network or a pysal weights object</span><span class="se">\</span>
<span class="s2">                 but not both&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">network</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">calc_access</span><span class="p">(</span><span class="n">data</span><span class="p">,</span>
                             <span class="n">variables</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                             <span class="n">network</span><span class="o">=</span><span class="n">network</span><span class="p">,</span>
                             <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                             <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">,</span>
                             <span class="n">precompute</span><span class="o">=</span><span class="n">precompute</span><span class="p">)</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;acc_&quot;</span> <span class="o">+</span> <span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">_build_local_environment</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">groups</span><span class="p">)</span>


<div class="viewcode-block" id="compute_segregation_profile"><a class="viewcode-back" href="../../../generated/segregation.spatial.compute_segregation_profile.html#segregation.spatial.compute_segregation_profile">[docs]</a><span class="k">def</span> <span class="nf">compute_segregation_profile</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span>
                                <span class="n">groups</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">distances</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">network</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                <span class="n">decay</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                <span class="n">function</span><span class="o">=</span><span class="s1">&#39;triangular&#39;</span><span class="p">,</span>
                                <span class="n">precompute</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute multiscalar segregation profile.</span>

<span class="sd">    This function calculates several Spatial Information Theory indices with</span>
<span class="sd">    increasing distance parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gdf : geopandas.GeoDataFrame</span>
<span class="sd">        geodataframe with rows as observations and columns as population</span>
<span class="sd">        variables. Note that if using a network distance, the coordinate</span>
<span class="sd">        system for this gdf should be 4326. If using euclidian distance,</span>
<span class="sd">        this must be projected into planar coordinates like state plane or UTM.</span>
<span class="sd">    groups : list</span>
<span class="sd">        list of variables .</span>
<span class="sd">    distances : list</span>
<span class="sd">        list of floats representing bandwidth distances that define a local</span>
<span class="sd">        environment.</span>
<span class="sd">    network : pandana.Network (optional)</span>
<span class="sd">        A pandana.Network likely created with</span>
<span class="sd">        `segregation.network.get_osm_network`.</span>
<span class="sd">    decay : str (optional)</span>
<span class="sd">        decay type to be used in pandana accessibility calculation (the</span>
<span class="sd">        default is &#39;linear&#39;).</span>
<span class="sd">    function: &#39;str&#39; (optional)</span>
<span class="sd">        which weighting function should be passed to libpysal.weights.Kernel</span>
<span class="sd">        must be one of: &#39;triangular&#39;,&#39;uniform&#39;,&#39;quadratic&#39;,&#39;quartic&#39;,&#39;gaussian&#39;</span>
<span class="sd">    precompute: bool</span>
<span class="sd">        Whether the pandana.Network instance should precompute the range</span>
<span class="sd">        queries.This is true by default, but if you plan to calculate several</span>
<span class="sd">        segregation profiles using the same network, then you can set this</span>
<span class="sd">        parameter to `False` to avoid precomputing repeatedly inside the</span>
<span class="sd">        function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dict</span>
<span class="sd">        dictionary with distances as keys and SIT statistics as values</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Based on Sean F. Reardon, Stephen A. Matthews, David O’Sullivan, Barrett A. Lee, Glenn Firebaugh, Chad R. Farrell, &amp; Kendra Bischoff. (2008). The Geographic Scale of Metropolitan Racial Segregation. Demography, 45(3), 489–514. https://doi.org/10.1353/dem.0.0019.</span>

<span class="sd">    Reference: :cite:`Reardon2008`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">gdf</span><span class="p">[</span><span class="n">groups</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="n">groups</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MultiInformationTheory</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">groups</span><span class="p">)</span><span class="o">.</span><span class="n">statistic</span>

    <span class="k">if</span> <span class="n">network</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">gdf</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;WGS 84&#39;</span><span class="p">:</span>
            <span class="n">gdf</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_crs</span><span class="p">(</span><span class="n">epsg</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>
        <span class="n">groups2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;acc_&#39;</span> <span class="o">+</span> <span class="n">group</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">precompute</span><span class="p">:</span>
            <span class="n">maxdist</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">network</span><span class="o">.</span><span class="n">precompute</span><span class="p">(</span><span class="n">maxdist</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>
            <span class="n">access</span> <span class="o">=</span> <span class="n">calc_access</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span>
                                 <span class="n">network</span><span class="p">,</span>
                                 <span class="n">decay</span><span class="o">=</span><span class="n">decay</span><span class="p">,</span>
                                 <span class="n">variables</span><span class="o">=</span><span class="n">groups</span><span class="p">,</span>
                                 <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                 <span class="n">precompute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">sit</span> <span class="o">=</span> <span class="n">MultiInformationTheory</span><span class="p">(</span><span class="n">access</span><span class="p">,</span> <span class="n">groups2</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">sit</span><span class="o">.</span><span class="n">statistic</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">distance</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">Kernel</span><span class="o">.</span><span class="n">from_dataframe</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span>
                                      <span class="n">bandwidth</span><span class="o">=</span><span class="n">distance</span><span class="p">,</span>
                                      <span class="n">function</span><span class="o">=</span><span class="n">function</span><span class="p">)</span>
            <span class="n">sit</span> <span class="o">=</span> <span class="n">SpatialInformationTheory</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">distance</span><span class="p">]</span> <span class="o">=</span> <span class="n">sit</span><span class="o">.</span><span class="n">statistic</span>
    <span class="k">return</span> <span class="n">indices</span></div>


<span class="c1"># Deprecation Calls</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Spatial_Prox_Prof&quot;</span><span class="p">,</span> <span class="s2">&quot;SpatialProxProf&quot;</span><span class="p">)</span>
<span class="n">Spatial_Prox_Prof</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">SpatialProxProf</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Spatial_Dissim&quot;</span><span class="p">,</span> <span class="s2">&quot;SpatialDissim&quot;</span><span class="p">)</span>
<span class="n">Spatial_Dissim</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">SpatialDissim</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Boundary_Spatial_Dissim&quot;</span><span class="p">,</span> <span class="s2">&quot;BoundarySpatialDissim&quot;</span><span class="p">)</span>
<span class="n">Boundary_Spatial_Dissim</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">BoundarySpatialDissim</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Perimeter_Area_Ratio_Spatial_Dissim&quot;</span><span class="p">,</span>
                   <span class="s2">&quot;PerimeterAreaRatioSpatialDissim&quot;</span><span class="p">)</span>
<span class="n">Perimeter_Area_Ratio_Spatial_Dissim</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span>
    <span class="n">PerimeterAreaRatioSpatialDissim</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Distance_Decay_Isolation&quot;</span><span class="p">,</span> <span class="s2">&quot;DistanceDecayIsolation&quot;</span><span class="p">)</span>
<span class="n">Distance_Decay_Isolation</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">DistanceDecayIsolation</span><span class="p">,</span>
                                             <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Distance_Decay_Exposure&quot;</span><span class="p">,</span> <span class="s2">&quot;DistanceDecayExposure&quot;</span><span class="p">)</span>
<span class="n">Distance_Decay_Exposure</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">DistanceDecayExposure</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Spatial_Proximity&quot;</span><span class="p">,</span> <span class="s2">&quot;SpatialProximity&quot;</span><span class="p">)</span>
<span class="n">Spatial_Proximity</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">SpatialProximity</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Absolute_Clustering&quot;</span><span class="p">,</span> <span class="s2">&quot;AbsoluteClustering&quot;</span><span class="p">)</span>
<span class="n">Absolute_Clustering</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">AbsoluteClustering</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Relative_Clustering&quot;</span><span class="p">,</span> <span class="s2">&quot;RelativeClustering&quot;</span><span class="p">)</span>
<span class="n">Relative_Clustering</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">RelativeClustering</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Absolute_Concentration&quot;</span><span class="p">,</span> <span class="s2">&quot;AbsoluteConcentration&quot;</span><span class="p">)</span>
<span class="n">Absolute_Concentration</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">AbsoluteConcentration</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Relative_Concentration&quot;</span><span class="p">,</span> <span class="s2">&quot;RelativeConcentration&quot;</span><span class="p">)</span>
<span class="n">Relative_Concentration</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">RelativeConcentration</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Absolute_Centralization&quot;</span><span class="p">,</span> <span class="s2">&quot;AbsoluteCentralization&quot;</span><span class="p">)</span>
<span class="n">Absolute_Centralization</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">AbsoluteCentralization</span><span class="p">,</span>
                                            <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>

<span class="n">msg</span> <span class="o">=</span> <span class="n">_dep_message</span><span class="p">(</span><span class="s2">&quot;Relative_Centralization&quot;</span><span class="p">,</span> <span class="s2">&quot;RelativeCentralization&quot;</span><span class="p">)</span>
<span class="n">Relative_Centralization</span> <span class="o">=</span> <span class="n">DeprecationHelper</span><span class="p">(</span><span class="n">RelativeCentralization</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.4.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>